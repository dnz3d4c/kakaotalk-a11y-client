# ì¹´ì¹´ì˜¤í†¡ ì ‘ê·¼ì„± í´ë¼ì´ì–¸íŠ¸ - ê°œì„  í”„ë¡¬í”„íŠ¸

**ëª©ì **: ì•ˆì •ì„± ê°•í™” + ì„±ëŠ¥ ìµœì í™”  
**ëŒ€ìƒ**: Claude Code  
**ìš°ì„ ìˆœìœ„**: 1ìˆœìœ„(ì•ˆì •ì„±/ì„±ëŠ¥) â†’ 2ìˆœìœ„(ì½”ë“œ í’ˆì§ˆ) â†’ 3ìˆœìœ„(ê¸°ëŠ¥ í™•ì¥)

---

## ğŸ“‹ ê°œì„  í•­ëª© ìš”ì•½

| # | í•­ëª© | ë¶„ë¥˜ | íŒŒì¼ | ìš°ì„ ìˆœìœ„ |
|---|------|------|------|----------|
| 1 | ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬ ì¶”ê°€ | ì§„ë‹¨ | ì‹ ê·œ: `utils/profiler.py` | ğŸ”´ ìµœìš°ì„  |
| ~~2~~ | ~~ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì ì‘í˜• ì¬ì‹œë„~~ | ~~ì•ˆì •ì„±~~ | ~~`context_menu.py`~~ | [íê¸°ë¨] |
| 3 | ë¹ˆ ListItem ìŠ¤ë§ˆíŠ¸ í•„í„°ë§ | ì„±ëŠ¥ | `uia_utils.py` | ğŸ”´ ìµœìš°ì„  |
| 4 | í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„°ë§ ìµœì í™” | ì„±ëŠ¥ | `main.py` | ğŸŸ¡ ë†’ìŒ |
| 5 | COM ì´ˆê¸°í™” í†µí•© ê´€ë¦¬ | ì„±ëŠ¥ | ì‹ ê·œ: `utils/com_manager.py` | ğŸŸ¡ ë†’ìŒ |
| 6 | keyboard ê°œë³„ unhook | ì•ˆì •ì„± | `keyboard_nav.py` | ğŸŸ¡ ë†’ìŒ |
| 7 | searchDepth ë™ì  ì¡°ì • | ì„±ëŠ¥ | `uia_utils.py` | ğŸŸ¢ ì¤‘ê°„ |

---

## 1. ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬ ì¶”ê°€ (ì§„ë‹¨ ë„êµ¬)

### ëª©ì 
- UIA íƒìƒ‰ ë³‘ëª© ì§€ì  ì‹ë³„
- ë¹ˆ ListItemì´ ì„±ëŠ¥ ë¬¸ì œì¸ì§€ ì •í™•ë„ ë¬¸ì œì¸ì§€ íŒë³„
- ê° ì‘ì—…ë³„ ì†Œìš” ì‹œê°„ ì¸¡ì •

### ì‹ ê·œ íŒŒì¼: `utils/profiler.py`

```python
"""
UIA ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬
- ê° ì‘ì—…ë³„ ì†Œìš” ì‹œê°„ ì¸¡ì •
- ë³‘ëª© ì§€ì  ìë™ ì‹ë³„
- ë¡œê·¸ íŒŒì¼ ì¶œë ¥
"""
import time
import logging
import functools
from contextlib import contextmanager
from dataclasses import dataclass, field
from typing import Dict, List, Optional
from pathlib import Path
import json
from datetime import datetime

# í”„ë¡œíŒŒì¼ ë¡œê±° ì„¤ì •
profile_logger = logging.getLogger('uia_profiler')
profile_logger.setLevel(logging.DEBUG)

# íŒŒì¼ í•¸ë“¤ëŸ¬ (ìƒì„¸ ë¡œê·¸)
log_dir = Path.home() / '.kakaotalk_a11y' / 'logs'
log_dir.mkdir(parents=True, exist_ok=True)
log_file = log_dir / f'profile_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
file_handler = logging.FileHandler(log_file, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s | %(message)s'))
profile_logger.addHandler(file_handler)


@dataclass
class ProfileMetrics:
    """í”„ë¡œíŒŒì¼ ë©”íŠ¸ë¦­ ì €ì¥"""
    call_count: int = 0
    total_time: float = 0.0
    min_time: float = float('inf')
    max_time: float = 0.0
    samples: List[float] = field(default_factory=list)
    
    @property
    def avg_time(self) -> float:
        return self.total_time / self.call_count if self.call_count > 0 else 0.0
    
    def record(self, elapsed: float):
        self.call_count += 1
        self.total_time += elapsed
        self.min_time = min(self.min_time, elapsed)
        self.max_time = max(self.max_time, elapsed)
        # ìµœê·¼ 100ê°œë§Œ ìœ ì§€
        self.samples.append(elapsed)
        if len(self.samples) > 100:
            self.samples.pop(0)


class UIAProfiler:
    """UIA ì‘ì—… í”„ë¡œíŒŒì¼ëŸ¬"""
    
    _instance: Optional['UIAProfiler'] = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
        self._initialized = True
        self.metrics: Dict[str, ProfileMetrics] = {}
        self.enabled = True
        self.slow_threshold_ms = 100  # 100ms ì´ìƒì´ë©´ ê²½ê³ 
        self._context_stack: List[str] = []
    
    @contextmanager
    def measure(self, operation: str):
        """ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €ë¡œ ì‹œê°„ ì¸¡ì •"""
        if not self.enabled:
            yield
            return
        
        full_name = f"{'.'.join(self._context_stack)}.{operation}" if self._context_stack else operation
        start = time.perf_counter()
        
        try:
            yield
        finally:
            elapsed_ms = (time.perf_counter() - start) * 1000
            
            if full_name not in self.metrics:
                self.metrics[full_name] = ProfileMetrics()
            self.metrics[full_name].record(elapsed_ms)
            
            # ëŠë¦° ì‘ì—… ê²½ê³ 
            if elapsed_ms > self.slow_threshold_ms:
                profile_logger.warning(f"ğŸ¢ SLOW: {full_name} took {elapsed_ms:.1f}ms")
            else:
                profile_logger.debug(f"â±ï¸ {full_name}: {elapsed_ms:.1f}ms")
    
    @contextmanager
    def context(self, name: str):
        """ì¤‘ì²© ì»¨í…ìŠ¤íŠ¸ (ì˜ˆ: chat_room.get_messages)"""
        self._context_stack.append(name)
        try:
            yield
        finally:
            self._context_stack.pop()
    
    def profile_uia_search(self, control_type: str, search_params: dict, result_count: int, elapsed_ms: float):
        """UIA ê²€ìƒ‰ ìƒì„¸ ë¡œê¹…"""
        params_str = ', '.join(f"{k}={v}" for k, v in search_params.items() if v)
        profile_logger.info(
            f"ğŸ” UIA Search: {control_type}({params_str}) "
            f"â†’ {result_count} results in {elapsed_ms:.1f}ms"
        )
        
        # ë¹ˆ ê²°ê³¼ê°€ ë§ìœ¼ë©´ ê²½ê³ 
        if result_count > 50:
            profile_logger.warning(f"âš ï¸ Large result set: {result_count} items - consider filtering")
    
    def profile_list_items(self, total: int, empty: int, valid: int, elapsed_ms: float):
        """ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ í•„í„°ë§ ë¡œê¹…"""
        empty_ratio = (empty / total * 100) if total > 0 else 0
        profile_logger.info(
            f"ğŸ“‹ ListItems: total={total}, empty={empty} ({empty_ratio:.0f}%), "
            f"valid={valid}, took {elapsed_ms:.1f}ms"
        )
        
        if empty_ratio > 80:
            profile_logger.warning(f"âš ï¸ High empty ratio ({empty_ratio:.0f}%) - virtual scroll detected")
    
    def get_report(self) -> str:
        """ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±"""
        lines = ["=" * 60, "UIA Performance Report", "=" * 60, ""]
        
        # ëŠë¦° ìˆœ ì •ë ¬
        sorted_metrics = sorted(
            self.metrics.items(),
            key=lambda x: x[1].avg_time,
            reverse=True
        )
        
        for name, m in sorted_metrics[:20]:  # ìƒìœ„ 20ê°œ
            lines.append(
                f"{name}:\n"
                f"  calls: {m.call_count}, avg: {m.avg_time:.1f}ms, "
                f"min: {m.min_time:.1f}ms, max: {m.max_time:.1f}ms"
            )
        
        return "\n".join(lines)
    
    def save_report(self, path: Optional[Path] = None):
        """ë¦¬í¬íŠ¸ íŒŒì¼ ì €ì¥"""
        if path is None:
            path = log_dir / f'report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.txt'
        
        with open(path, 'w', encoding='utf-8') as f:
            f.write(self.get_report())
        
        # JSONìœ¼ë¡œë„ ì €ì¥ (ë¶„ì„ìš©)
        json_path = path.with_suffix('.json')
        data = {
            name: {
                'call_count': m.call_count,
                'avg_time': m.avg_time,
                'min_time': m.min_time if m.min_time != float('inf') else 0,
                'max_time': m.max_time,
            }
            for name, m in self.metrics.items()
        }
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2)
        
        return path


# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
profiler = UIAProfiler()


def profile(operation: str = None):
    """ë°ì½”ë ˆì´í„°ë¡œ í•¨ìˆ˜ í”„ë¡œíŒŒì¼ë§"""
    def decorator(func):
        op_name = operation or func.__name__
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with profiler.measure(op_name):
                return func(*args, **kwargs)
        
        return wrapper
    return decorator


# í¸ì˜ í•¨ìˆ˜
def log_slow(message: str, elapsed_ms: float, threshold_ms: float = 100):
    """ëŠë¦° ì‘ì—… ì¡°ê±´ë¶€ ë¡œê¹…"""
    if elapsed_ms > threshold_ms:
        profile_logger.warning(f"ğŸ¢ {message}: {elapsed_ms:.1f}ms (threshold: {threshold_ms}ms)")
```

### ì‚¬ìš© ì˜ˆì‹œ (ê¸°ì¡´ ì½”ë“œì— ì ìš©)

```python
# uia_utils.py ìˆ˜ì •
from utils.profiler import profiler, profile

@profile("get_children_recursive")
def get_children_recursive(control, max_depth=2, filter_empty=True):
    start = time.perf_counter()
    children = control.GetChildren()
    total_count = len(children)
    
    # ... ê¸°ì¡´ ë¡œì§ ...
    
    elapsed_ms = (time.perf_counter() - start) * 1000
    profiler.profile_list_items(
        total=total_count,
        empty=empty_count,
        valid=len(result),
        elapsed_ms=elapsed_ms
    )
    return result


# context_menu.py ìˆ˜ì •
from utils.profiler import profiler

def _find_popup_menu(self) -> bool:
    with profiler.context("context_menu"):
        with profiler.measure("find_eva_menu"):
            eva_menu = root.MenuControl(searchDepth=10, ClassName='EVA_Menu')
        # ...
```

---

## ~~2. ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì ì‘í˜• ì¬ì‹œë„~~ [íê¸°ë¨]

> **íê¸° ì‚¬ìœ **: context_menu.py ì œê±°ë¨ (2025-12-31). NVDA ë„¤ì´í‹°ë¸Œ ë™ì‘ì— ìœ„ì„.
> ì•„ë˜ ì½”ë“œëŠ” ì°¸ê³ ìš© ê³¼ê±° ì„¤ê³„ì•ˆì…ë‹ˆë‹¤.

### í˜„ì¬ ë¬¸ì œ
- ê³ ì • 5íšŒ ì¬ì‹œë„, ê³ ì • 100ms ê°„ê²©
- ì„±ê³µë¥  ë°ì´í„° ì—†ì´ ë§¹ëª©ì  ì¬ì‹œë„

### ê°œì„  ë°©í–¥
- ì„±ê³µ ì´ë ¥ ê¸°ë°˜ ì ì‘í˜• ì¬ì‹œë„
- ë°©ë²•ë³„ ì„±ê³µë¥  ì¶”ì  â†’ ì„±ê³µë¥  ë†’ì€ ë°©ë²• ë¨¼ì € ì‹œë„
- ì§€ìˆ˜ ë°±ì˜¤í”„ (exponential backoff)

### ìˆ˜ì • íŒŒì¼: `navigation/context_menu.py`

```python
"""
ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì²˜ë¦¬ - ì ì‘í˜• ì¬ì‹œë„ ë²„ì „
"""
import time
import uiautomation as auto
from dataclasses import dataclass
from typing import Optional, Callable, List
from utils.profiler import profiler, profile_logger


@dataclass
class MenuSearchMethod:
    """ë©”ë‰´ íƒìƒ‰ ë°©ë²•"""
    name: str
    func: Callable[[], Optional[auto.MenuControl]]
    success_count: int = 0
    fail_count: int = 0
    total_time_ms: float = 0.0
    
    @property
    def success_rate(self) -> float:
        total = self.success_count + self.fail_count
        return self.success_count / total if total > 0 else 0.5  # ì´ˆê¸°ê°’ 50%
    
    @property
    def avg_time_ms(self) -> float:
        return self.total_time_ms / self.success_count if self.success_count > 0 else 500.0
    
    @property
    def score(self) -> float:
        """ì„±ê³µë¥  * (1 / í‰ê· ì‹œê°„) = íš¨ìœ¨ ì ìˆ˜"""
        return self.success_rate / (self.avg_time_ms / 1000 + 0.1)


class AdaptiveMenuFinder:
    """ì ì‘í˜• ë©”ë‰´ íƒìƒ‰ê¸°"""
    
    def __init__(self):
        self.methods: List[MenuSearchMethod] = []
        self._init_methods()
        
        # ì¬ì‹œë„ ì„¤ì •
        self.max_retries = 7
        self.initial_delay_ms = 150
        self.max_delay_ms = 500
        self.backoff_factor = 1.5
    
    def _init_methods(self):
        """íƒìƒ‰ ë°©ë²• ì´ˆê¸°í™”"""
        self.methods = [
            MenuSearchMethod(
                name="eva_menu_deep",
                func=self._method_eva_menu_deep
            ),
            MenuSearchMethod(
                name="kakao_windows",
                func=self._method_kakao_windows
            ),
            MenuSearchMethod(
                name="generic_menu",
                func=self._method_generic_menu
            ),
            MenuSearchMethod(
                name="popup_mode_check",
                func=self._method_popup_mode_check
            ),
        ]
    
    def _method_eva_menu_deep(self) -> Optional[auto.MenuControl]:
        """ë°©ë²• 1: EVA_Menu í´ë˜ìŠ¤ ê¹Šì€ ê²€ìƒ‰"""
        root = auto.GetRootControl()
        menu = root.MenuControl(searchDepth=10, ClassName='EVA_Menu')
        return menu if menu.Exists(timeout=0.05) else None
    
    def _method_kakao_windows(self) -> Optional[auto.MenuControl]:
        """ë°©ë²• 2: ì¹´ì¹´ì˜¤í†¡ ì°½ë“¤ ë‚´ì—ì„œ ê²€ìƒ‰"""
        root = auto.GetRootControl()
        for win in root.GetChildren():
            if 'EVA_' in (win.ClassName or ''):
                menu = win.MenuControl(searchDepth=5, ClassName='EVA_Menu')
                if menu.Exists(timeout=0.05):
                    return menu
        return None
    
    def _method_generic_menu(self) -> Optional[auto.MenuControl]:
        """ë°©ë²• 3: ì¼ë°˜ MenuControl ê²€ìƒ‰"""
        root = auto.GetRootControl()
        menu = root.MenuControl(searchDepth=10)
        return menu if menu.Exists(timeout=0.05) else None
    
    def _method_popup_mode_check(self) -> Optional[auto.MenuControl]:
        """ë°©ë²• 4: Win32 íŒì—… ëª¨ë“œ í™•ì¸ í›„ ì¬ê²€ìƒ‰"""
        import win32gui
        import win32con
        
        def is_popup(hwnd, _):
            style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
            if style & win32con.WS_POPUP:
                class_name = win32gui.GetClassName(hwnd)
                if 'EVA_' in class_name:
                    return False  # ì°¾ìŒ, ì—´ê±° ì¤‘ë‹¨
            return True
        
        try:
            win32gui.EnumWindows(is_popup, None)
        except:
            pass  # ì—´ê±° ì¤‘ë‹¨ë¨ = íŒì—… ì°¾ìŒ
        
        root = auto.GetRootControl()
        menu = root.MenuControl(searchDepth=15, ClassName='EVA_Menu')
        return menu if menu.Exists(timeout=0.05) else None
    
    def _get_sorted_methods(self) -> List[MenuSearchMethod]:
        """ì„±ê³µë¥  ê¸°ë°˜ ì •ë ¬"""
        return sorted(self.methods, key=lambda m: m.score, reverse=True)
    
    @profile("find_context_menu")
    def find_menu(self) -> Optional[auto.MenuControl]:
        """ì ì‘í˜• ë©”ë‰´ íƒìƒ‰"""
        delay_ms = self.initial_delay_ms
        
        for attempt in range(self.max_retries):
            profile_logger.debug(f"ë©”ë‰´ ì°¾ê¸° ì‹œë„ {attempt + 1}/{self.max_retries}")
            
            # ì„±ê³µë¥  ë†’ì€ ìˆœì„œë¡œ ì‹œë„
            sorted_methods = self._get_sorted_methods()
            
            for method in sorted_methods:
                start = time.perf_counter()
                
                try:
                    result = method.func()
                    elapsed_ms = (time.perf_counter() - start) * 1000
                    
                    if result:
                        # ì„±ê³µ ê¸°ë¡
                        method.success_count += 1
                        method.total_time_ms += elapsed_ms
                        profile_logger.info(
                            f"âœ… ë©”ë‰´ ë°œê²¬: {method.name} "
                            f"(attempt {attempt + 1}, {elapsed_ms:.0f}ms, "
                            f"success_rate: {method.success_rate:.0%})"
                        )
                        return result
                    else:
                        method.fail_count += 1
                        
                except Exception as e:
                    method.fail_count += 1
                    profile_logger.warning(f"ë©”ë‰´ íƒìƒ‰ ì˜¤ë¥˜ ({method.name}): {e}")
            
            # ì§€ìˆ˜ ë°±ì˜¤í”„
            time.sleep(delay_ms / 1000)
            delay_ms = min(delay_ms * self.backoff_factor, self.max_delay_ms)
        
        profile_logger.error(f"âŒ ë©”ë‰´ ì°¾ê¸° ì‹¤íŒ¨ (ì´ {self.max_retries}íšŒ ì‹œë„)")
        self._log_method_stats()
        return None
    
    def _log_method_stats(self):
        """ë°©ë²•ë³„ í†µê³„ ë¡œê¹…"""
        profile_logger.info("=== ë©”ë‰´ íƒìƒ‰ ë°©ë²•ë³„ í†µê³„ ===")
        for m in self.methods:
            profile_logger.info(
                f"  {m.name}: success_rate={m.success_rate:.0%}, "
                f"avg_time={m.avg_time_ms:.0f}ms, score={m.score:.2f}"
            )


class ContextMenuNavigator:
    """ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë„¤ë¹„ê²Œì´í„° (ê°œì„  ë²„ì „)"""
    
    def __init__(self):
        self.menu_finder = AdaptiveMenuFinder()
        self.current_menu: Optional[auto.MenuControl] = None
        self.menu_items: List[auto.Control] = []
        self.current_index: int = 0
    
    def open_menu(self, target_control: auto.Control) -> bool:
        """ëŒ€ìƒ ì»¨íŠ¸ë¡¤ì—ì„œ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì—´ê¸°"""
        with profiler.context("context_menu"):
            # ìš°í´ë¦­
            with profiler.measure("right_click"):
                target_control.RightClick()
            
            # ì´ˆê¸° ëŒ€ê¸° (ë Œë”ë§)
            time.sleep(0.2)
            
            # ì ì‘í˜• ë©”ë‰´ íƒìƒ‰
            self.current_menu = self.menu_finder.find_menu()
            
            if self.current_menu:
                with profiler.measure("get_menu_items"):
                    self._load_menu_items()
                return True
            
            return False
    
    def _load_menu_items(self):
        """ë©”ë‰´ ì•„ì´í…œ ë¡œë“œ"""
        self.menu_items = []
        self.current_index = 0
        
        if not self.current_menu:
            return
        
        children = self.current_menu.GetChildren()
        for child in children:
            # MenuItemControlë§Œ ìˆ˜ì§‘
            if child.ControlType == auto.ControlType.MenuItemControl:
                if child.Name:  # ì´ë¦„ ìˆëŠ” ê²ƒë§Œ
                    self.menu_items.append(child)
        
        profile_logger.debug(f"ë©”ë‰´ ì•„ì´í…œ {len(self.menu_items)}ê°œ ë¡œë“œ")
    
    # ... (ë‚˜ë¨¸ì§€ ë©”ì„œë“œ: move_up, move_down, select, close ë“±)
```

---

## 3. ë¹ˆ ListItem ìŠ¤ë§ˆíŠ¸ í•„í„°ë§

### í˜„ì¬ ë¬¸ì œ
- 164ê°œ ë¹ˆ í•­ëª©ì„ ë§¤ë²ˆ ìˆœíšŒ
- í•„í„°ë§ ìì²´ê°€ ë³‘ëª©ì¸ì§€ ë¶ˆëª…í™•

### ê°œì„  ë°©í–¥
- ì¡°ê¸° ì¢…ë£Œ (early exit) íŒ¨í„´
- ìœ íš¨ ì˜ì—­ ìºì‹±
- ìƒì„¸ í”„ë¡œíŒŒì¼ë§

### ìˆ˜ì • íŒŒì¼: `utils/uia_utils.py`

```python
"""
UIA ìœ í‹¸ë¦¬í‹° - ìŠ¤ë§ˆíŠ¸ í•„í„°ë§ ë²„ì „
"""
import time
from typing import List, Optional, Tuple
import uiautomation as auto
from utils.profiler import profiler, profile_logger


class SmartListFilter:
    """ë¹ˆ ListItem ìŠ¤ë§ˆíŠ¸ í•„í„°"""
    
    def __init__(self):
        # ìºì‹±: ë§ˆì§€ë§‰ìœ¼ë¡œ ìœ íš¨í–ˆë˜ ì¸ë±ìŠ¤ ë²”ìœ„
        self._valid_range_cache: Optional[Tuple[int, int]] = None
        self._cache_hit_count = 0
        self._cache_miss_count = 0
    
    def filter_list_items(
        self,
        parent: auto.Control,
        max_items: int = 100,
        use_cache: bool = True
    ) -> List[auto.Control]:
        """
        ë¹ˆ ListItem í•„í„°ë§ (ìµœì í™” ë²„ì „)
        
        ì „ëµ:
        1. ìºì‹œëœ ìœ íš¨ ë²”ìœ„ë¶€í„° ê²€ì‚¬ (ë¹ ë¥¸ ê²½ë¡œ)
        2. ì—°ì† ë¹ˆ í•­ëª© 10ê°œ ë°œê²¬ ì‹œ ì¡°ê¸° ì¢…ë£Œ
        3. ìƒì„¸ í”„ë¡œíŒŒì¼ë§
        """
        start = time.perf_counter()
        
        with profiler.measure("GetChildren"):
            children = parent.GetChildren()
        
        total_count = len(children)
        profile_logger.debug(f"ListItems í•„í„°ë§ ì‹œì‘: total={total_count}")
        
        if total_count == 0:
            return []
        
        valid_items: List[auto.Control] = []
        empty_count = 0
        consecutive_empty = 0
        max_consecutive_empty = 15  # ì—°ì† ë¹ˆ í•­ëª© í•œê³„
        
        # ìºì‹œ í™œìš© (ì´ì „ì— ìœ íš¨í–ˆë˜ ë²”ìœ„ ë¨¼ì €)
        start_idx = 0
        if use_cache and self._valid_range_cache:
            cached_start, cached_end = self._valid_range_cache
            if cached_start < total_count:
                start_idx = max(0, cached_start - 5)  # ì•½ê°„ì˜ ì—¬ìœ 
                self._cache_hit_count += 1
                profile_logger.debug(f"ìºì‹œ íˆíŠ¸: ì¸ë±ìŠ¤ {start_idx}ë¶€í„° ê²€ì‚¬")
        
        # ìºì‹œ ë²”ìœ„ ë¨¼ì € ê²€ì‚¬
        indices_to_check = list(range(start_idx, total_count))
        # ìºì‹œ ì´ì „ ë²”ìœ„ë„ ì¶”ê°€ (ë’¤ì—)
        if start_idx > 0:
            indices_to_check.extend(range(0, start_idx))
        
        first_valid_idx = -1
        last_valid_idx = -1
        
        with profiler.measure("filter_loop"):
            for i in indices_to_check:
                if len(valid_items) >= max_items:
                    profile_logger.debug(f"ìµœëŒ€ í•­ëª© ìˆ˜ ë„ë‹¬: {max_items}")
                    break
                
                child = children[i]
                
                # ë¹ˆ í•­ëª© ì²´í¬ (Name ì—†ê±°ë‚˜ ê³µë°±ë§Œ)
                name = child.Name
                is_empty = not name or not name.strip()
                
                if is_empty:
                    empty_count += 1
                    consecutive_empty += 1
                    
                    # ì¡°ê¸° ì¢…ë£Œ: ìœ íš¨ í•­ëª© ìˆê³  ì—°ì† ë¹ˆ í•­ëª© ì´ˆê³¼
                    if valid_items and consecutive_empty > max_consecutive_empty:
                        profile_logger.debug(
                            f"ì¡°ê¸° ì¢…ë£Œ: ì—°ì† ë¹ˆ í•­ëª© {consecutive_empty}ê°œ "
                            f"(ì¸ë±ìŠ¤ {i}/{total_count})"
                        )
                        break
                else:
                    valid_items.append(child)
                    consecutive_empty = 0
                    
                    if first_valid_idx == -1:
                        first_valid_idx = i
                    last_valid_idx = i
        
        # ìºì‹œ ì—…ë°ì´íŠ¸
        if first_valid_idx >= 0:
            self._valid_range_cache = (first_valid_idx, last_valid_idx)
        
        elapsed_ms = (time.perf_counter() - start) * 1000
        
        # ìƒì„¸ í”„ë¡œíŒŒì¼ë§
        profiler.profile_list_items(
            total=total_count,
            empty=empty_count,
            valid=len(valid_items),
            elapsed_ms=elapsed_ms
        )
        
        # í†µê³„ ë¡œê¹…
        cache_rate = self._cache_hit_count / (self._cache_hit_count + self._cache_miss_count + 1)
        profile_logger.info(
            f"ListItems ê²°ê³¼: {len(valid_items)}/{total_count} ìœ íš¨, "
            f"ìºì‹œ íˆíŠ¸ìœ¨: {cache_rate:.0%}, {elapsed_ms:.1f}ms"
        )
        
        return valid_items


# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
smart_filter = SmartListFilter()


def get_children_filtered(
    parent: auto.Control,
    max_items: int = 100,
    control_type: Optional[int] = None
) -> List[auto.Control]:
    """
    í•„í„°ë§ëœ ìì‹ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
    
    Args:
        parent: ë¶€ëª¨ ì»¨íŠ¸ë¡¤
        max_items: ìµœëŒ€ ë°˜í™˜ ê°œìˆ˜
        control_type: í•„í„°ë§í•  ControlType (Noneì´ë©´ ëª¨ë“  íƒ€ì…)
    
    Returns:
        ìœ íš¨í•œ ìì‹ ì»¨íŠ¸ë¡¤ ë¦¬ìŠ¤íŠ¸
    """
    items = smart_filter.filter_list_items(parent, max_items)
    
    if control_type:
        items = [item for item in items if item.ControlType == control_type]
    
    return items


def find_control_safe(
    parent: auto.Control,
    control_type: str,
    search_params: dict,
    timeout: float = 2.0
) -> Optional[auto.Control]:
    """
    ì•ˆì „í•œ ì»¨íŠ¸ë¡¤ ê²€ìƒ‰ (í”„ë¡œíŒŒì¼ë§ í¬í•¨)
    
    Args:
        parent: ë¶€ëª¨ ì»¨íŠ¸ë¡¤
        control_type: ì»¨íŠ¸ë¡¤ íƒ€ì…ëª… (ì˜ˆ: "ButtonControl")
        search_params: ê²€ìƒ‰ íŒŒë¼ë¯¸í„° (Name, ClassName ë“±)
        timeout: íƒ€ì„ì•„ì›ƒ (ì´ˆ)
    
    Returns:
        ì°¾ì€ ì»¨íŠ¸ë¡¤ ë˜ëŠ” None
    """
    start = time.perf_counter()
    
    try:
        control_class = getattr(auto, control_type)
        control = control_class(searchFromControl=parent, **search_params)
        
        exists = control.Exists(timeout=timeout)
        elapsed_ms = (time.perf_counter() - start) * 1000
        
        profiler.profile_uia_search(
            control_type=control_type,
            search_params=search_params,
            result_count=1 if exists else 0,
            elapsed_ms=elapsed_ms
        )
        
        return control if exists else None
        
    except Exception as e:
        elapsed_ms = (time.perf_counter() - start) * 1000
        profile_logger.error(f"UIA ê²€ìƒ‰ ì˜¤ë¥˜: {control_type} - {e} ({elapsed_ms:.1f}ms)")
        return None
```

---

## 4. í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„°ë§ ìµœì í™”

### í˜„ì¬ ë¬¸ì œ
- ì§€ì†ì  í´ë§ìœ¼ë¡œ CPU ì‚¬ìš©
- ì ì‘í˜• ê°„ê²©ì´ì§€ë§Œ ì—¬ì „íˆ ë¹„íš¨ìœ¨

### ê°œì„  ë°©í–¥
- ìœˆë„ìš° ë©”ì‹œì§€ í›… í™œìš© (ì„ íƒì )
- ë” ì •êµí•œ ì ì‘í˜• ê°„ê²©
- ë¶ˆí•„ìš”í•œ UIA í˜¸ì¶œ ìµœì†Œí™”

### ìˆ˜ì • íŒŒì¼: `main.py`

```python
"""
í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„°ë§ ìµœì í™” ë²„ì „
"""
import time
import threading
from enum import Enum, auto
from typing import Optional
import win32gui
import win32con
import uiautomation as uia
from utils.profiler import profiler, profile_logger


class ActivityLevel(Enum):
    """í™œë™ ìˆ˜ì¤€"""
    IDLE = auto()        # ë¹„í™œì„±
    LOW = auto()         # ë‚®ì€ í™œë™
    NORMAL = auto()      # ì¼ë°˜
    HIGH = auto()        # ë†’ì€ í™œë™ (ë©”ë‰´ ì—´ë¦¼ ë“±)


class OptimizedFocusMonitor:
    """ìµœì í™”ëœ í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„°"""
    
    # í™œë™ ìˆ˜ì¤€ë³„ í´ë§ ê°„ê²© (ms)
    POLL_INTERVALS = {
        ActivityLevel.IDLE: 1000,    # 1ì´ˆ (ë¹„í™œì„± ì‹œ)
        ActivityLevel.LOW: 500,      # 0.5ì´ˆ
        ActivityLevel.NORMAL: 200,   # 0.2ì´ˆ
        ActivityLevel.HIGH: 50,      # 50ms (ë©”ë‰´ ë“±)
    }
    
    def __init__(self, speak_callback):
        self.speak = speak_callback
        self.running = False
        self.thread: Optional[threading.Thread] = None
        
        # ìƒíƒœ
        self.activity_level = ActivityLevel.IDLE
        self.last_focus_name: Optional[str] = None
        self.last_focus_time: float = 0
        self.last_activity_time: float = 0
        
        # ì¹´ì¹´ì˜¤í†¡ ì°½ í•¸ë“¤ ìºì‹±
        self._kakao_hwnd: Optional[int] = None
        self._hwnd_cache_time: float = 0
        self._hwnd_cache_ttl: float = 5.0  # 5ì´ˆë§ˆë‹¤ ê°±ì‹ 
        
        # í†µê³„
        self.poll_count = 0
        self.skip_count = 0
        self.uia_call_count = 0
    
    def start(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if self.running:
            return
        
        self.running = True
        self.thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.thread.start()
        profile_logger.info("í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„° ì‹œì‘")
    
    def stop(self):
        """ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=1)
        
        # í†µê³„ ì¶œë ¥
        total_polls = self.poll_count + self.skip_count
        skip_rate = self.skip_count / total_polls if total_polls > 0 else 0
        profile_logger.info(
            f"í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„° í†µê³„: polls={self.poll_count}, "
            f"skips={self.skip_count} ({skip_rate:.0%}), "
            f"uia_calls={self.uia_call_count}"
        )
    
    def set_activity_level(self, level: ActivityLevel):
        """í™œë™ ìˆ˜ì¤€ ì„¤ì • (ì™¸ë¶€ì—ì„œ í˜¸ì¶œ)"""
        if level != self.activity_level:
            profile_logger.debug(f"í™œë™ ìˆ˜ì¤€ ë³€ê²½: {self.activity_level.name} â†’ {level.name}")
            self.activity_level = level
            self.last_activity_time = time.time()
    
    def _get_kakao_hwnd(self) -> Optional[int]:
        """ì¹´ì¹´ì˜¤í†¡ ì°½ í•¸ë“¤ (ìºì‹±)"""
        now = time.time()
        
        if self._kakao_hwnd and (now - self._hwnd_cache_time) < self._hwnd_cache_ttl:
            return self._kakao_hwnd
        
        # ìºì‹œ ë§Œë£Œ, ë‹¤ì‹œ ì°¾ê¸°
        fg_hwnd = win32gui.GetForegroundWindow()
        try:
            class_name = win32gui.GetClassName(fg_hwnd)
            if 'EVA_' in class_name or 'Kakao' in class_name:
                self._kakao_hwnd = fg_hwnd
                self._hwnd_cache_time = now
                return fg_hwnd
        except:
            pass
        
        return None
    
    def _should_skip_poll(self) -> bool:
        """í´ë§ ìŠ¤í‚µ ì—¬ë¶€ íŒë‹¨"""
        # 1. ì¹´ì¹´ì˜¤í†¡ì´ í¬ê·¸ë¼ìš´ë“œê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µ
        kakao_hwnd = self._get_kakao_hwnd()
        if not kakao_hwnd:
            return True
        
        fg_hwnd = win32gui.GetForegroundWindow()
        if fg_hwnd != kakao_hwnd:
            return True
        
        # 2. ìµœê·¼ í™œë™ì´ ì—†ìœ¼ë©´ IDLEë¡œ ì „í™˜
        if time.time() - self.last_activity_time > 10:  # 10ì´ˆ ë¬´í™œë™
            if self.activity_level != ActivityLevel.IDLE:
                self.set_activity_level(ActivityLevel.IDLE)
        
        return False
    
    def _monitor_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        # ì›œì—… ê¸°ê°„
        warmup_end = time.time() + 3
        
        while self.running:
            # ì›œì—…
            if time.time() < warmup_end:
                time.sleep(0.5)
                continue
            
            # ìŠ¤í‚µ ì²´í¬
            if self._should_skip_poll():
                self.skip_count += 1
                time.sleep(0.5)
                continue
            
            self.poll_count += 1
            
            # UIA í¬ì»¤ìŠ¤ í™•ì¸
            try:
                with profiler.measure("GetFocusedControl"):
                    focused = uia.GetFocusedControl()
                    self.uia_call_count += 1
                
                if focused:
                    self._process_focus_change(focused)
                    
            except Exception as e:
                profile_logger.warning(f"í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„° ì˜¤ë¥˜: {e}")
            
            # ì ì‘í˜• ëŒ€ê¸°
            interval = self.POLL_INTERVALS[self.activity_level]
            time.sleep(interval / 1000)
    
    def _process_focus_change(self, focused: uia.Control):
        """í¬ì»¤ìŠ¤ ë³€ê²½ ì²˜ë¦¬"""
        name = focused.Name
        control_type = focused.ControlTypeName
        
        # ë³€ê²½ ì—†ìœ¼ë©´ ë¬´ì‹œ
        if name == self.last_focus_name:
            return
        
        # ë””ë°”ìš´ì‹±: 50ms í›„ ì¬í™•ì¸
        time.sleep(0.05)
        focused2 = uia.GetFocusedControl()
        self.uia_call_count += 1
        
        if not focused2 or focused2.Name != name:
            return  # ë¶ˆì•ˆì •í•œ ë³€ê²½, ë¬´ì‹œ
        
        # ìœ íš¨í•œ ë³€ê²½
        self.last_focus_name = name
        self.last_focus_time = time.time()
        self.last_activity_time = time.time()
        
        # í™œë™ ìˆ˜ì¤€ ìë™ ì¡°ì •
        if 'Menu' in control_type:
            self.set_activity_level(ActivityLevel.HIGH)
        elif 'Tab' in control_type or 'List' in control_type:
            self.set_activity_level(ActivityLevel.NORMAL)
        else:
            self.set_activity_level(ActivityLevel.LOW)
        
        # ìŒì„± ì¶œë ¥
        if name:
            self.speak(f"{name}, {control_type}")
            profile_logger.debug(f"í¬ì»¤ìŠ¤: {name} ({control_type})")
```

---

## 5. COM ì´ˆê¸°í™” í†µí•© ê´€ë¦¬

### í˜„ì¬ ë¬¸ì œ
- ê° ë„¤ë¹„ê²Œì´í„°ì—ì„œ `pythoncom.CoInitialize()` ì¤‘ë³µ í˜¸ì¶œ

### ê°œì„ : ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € íŒ¨í„´

### ì‹ ê·œ íŒŒì¼: `utils/com_manager.py`

```python
"""
COM ì´ˆê¸°í™” í†µí•© ê´€ë¦¬
- ìŠ¤ë ˆë“œë‹¹ 1íšŒ ì´ˆê¸°í™” ë³´ì¥
- ìë™ ì •ë¦¬
"""
import threading
import pythoncom
from contextlib import contextmanager
from typing import Set
from utils.profiler import profile_logger


class COMManager:
    """COM ì´ˆê¸°í™” ê´€ë¦¬ì"""
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized_threads: Set[int] = set()
        return cls._instance
    
    def ensure_initialized(self) -> bool:
        """
        í˜„ì¬ ìŠ¤ë ˆë“œì—ì„œ COMì´ ì´ˆê¸°í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³ ,
        ì•ˆ ë˜ì–´ ìˆìœ¼ë©´ ì´ˆê¸°í™”
        
        Returns:
            True if newly initialized, False if already initialized
        """
        thread_id = threading.current_thread().ident
        
        if thread_id in self._initialized_threads:
            return False  # ì´ë¯¸ ì´ˆê¸°í™”ë¨
        
        with self._lock:
            if thread_id not in self._initialized_threads:
                pythoncom.CoInitialize()
                self._initialized_threads.add(thread_id)
                profile_logger.debug(f"COM ì´ˆê¸°í™”: thread {thread_id}")
                return True
        
        return False
    
    def uninitialize(self):
        """í˜„ì¬ ìŠ¤ë ˆë“œ COM í•´ì œ"""
        thread_id = threading.current_thread().ident
        
        with self._lock:
            if thread_id in self._initialized_threads:
                try:
                    pythoncom.CoUninitialize()
                except:
                    pass
                self._initialized_threads.discard(thread_id)
                profile_logger.debug(f"COM í•´ì œ: thread {thread_id}")


# ì‹±ê¸€í†¤
com_manager = COMManager()


@contextmanager
def com_initialized():
    """
    COM ì´ˆê¸°í™” ë³´ì¥ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €
    
    ì‚¬ìš©:
        with com_initialized():
            # UIA ì‘ì—…
    """
    newly_initialized = com_manager.ensure_initialized()
    try:
        yield
    finally:
        # ì´ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì´ˆê¸°í™”í–ˆìœ¼ë©´ í•´ì œ
        # (ì¬ì§„ì… ì‹œì—ëŠ” í•´ì œ ì•ˆ í•¨)
        if newly_initialized:
            com_manager.uninitialize()


def ensure_com():
    """ë°ì½”ë ˆì´í„°: COM ì´ˆê¸°í™” ë³´ì¥"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            com_manager.ensure_initialized()
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì˜ˆì‹œ

```python
# navigation/chat_room.py (ìˆ˜ì • ì „)
def enter(self, hwnd: int) -> bool:
    pythoncom.CoInitialize()  # ë§¤ë²ˆ í˜¸ì¶œ
    parent_control = auto.ControlFromHandle(hwnd)
    ...

# navigation/chat_room.py (ìˆ˜ì • í›„)
from utils.com_manager import com_initialized, com_manager

def enter(self, hwnd: int) -> bool:
    com_manager.ensure_initialized()  # ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ìŠ¤í‚µ
    parent_control = auto.ControlFromHandle(hwnd)
    ...

# ë˜ëŠ” ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì‚¬ìš©
def some_uia_operation(self):
    with com_initialized():
        # UIA ì‘ì—…
        pass
```

---

## 6. keyboard ê°œë³„ unhook

### í˜„ì¬ ë¬¸ì œ
```python
keyboard.unhook_all()  # ë‹¤ë¥¸ ëª¨ë“ˆ í›„í‚¹ë„ ì œê±°ë¨
```

### ê°œì„ : í›„í‚¹ í•¸ë“¤ ê´€ë¦¬

### ìˆ˜ì • íŒŒì¼: `keyboard_nav.py`

```python
"""
í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ - ê°œë³„ unhook ë²„ì „
"""
import keyboard
from typing import Dict, Callable, Optional
from utils.profiler import profile_logger


class KeyboardNavigator:
    """í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´í„° (ê°œì„  ë²„ì „)"""
    
    def __init__(self):
        self._hooks: Dict[str, keyboard.KeyboardEvent] = {}
        self._enabled = False
    
    def _register_key(self, key: str, callback: Callable, suppress: bool = False):
        """ê°œë³„ í‚¤ ë“±ë¡ (í•¸ë“¤ ì €ì¥)"""
        if key in self._hooks:
            # ì´ë¯¸ ë“±ë¡ëœ í‚¤ë©´ ë¨¼ì € ì œê±°
            self._unregister_key(key)
        
        hook = keyboard.on_press_key(key, callback, suppress=suppress)
        self._hooks[key] = hook
        profile_logger.debug(f"í‚¤ ë“±ë¡: {key}")
    
    def _unregister_key(self, key: str):
        """ê°œë³„ í‚¤ í•´ì œ"""
        if key in self._hooks:
            try:
                keyboard.unhook(self._hooks[key])
            except:
                pass
            del self._hooks[key]
            profile_logger.debug(f"í‚¤ í•´ì œ: {key}")
    
    def enable(self):
        """ë„¤ë¹„ê²Œì´ì…˜ í™œì„±í™”"""
        if self._enabled:
            return
        
        # NVDA í˜¸í™˜: suppress=False
        self._register_key('up', self._handle_up, suppress=False)
        self._register_key('down', self._handle_down, suppress=False)
        self._register_key('left', self._handle_left, suppress=False)
        self._register_key('right', self._handle_right, suppress=False)
        self._register_key('enter', self._handle_enter, suppress=False)
        self._register_key('escape', self._handle_escape, suppress=False)
        self._register_key('space', self._handle_space, suppress=False)
        
        self._enabled = True
        profile_logger.info(f"í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ í™œì„±í™”: {len(self._hooks)}ê°œ í‚¤")
    
    def disable(self):
        """ë„¤ë¹„ê²Œì´ì…˜ ë¹„í™œì„±í™” (ê°œë³„ unhook)"""
        if not self._enabled:
            return
        
        # ë“±ë¡ëœ í‚¤ë§Œ ê°œë³„ í•´ì œ
        keys_to_remove = list(self._hooks.keys())
        for key in keys_to_remove:
            self._unregister_key(key)
        
        self._enabled = False
        profile_logger.info("í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ë¹„í™œì„±í™”")
    
    def _handle_up(self, event):
        # êµ¬í˜„
        pass
    
    def _handle_down(self, event):
        pass
    
    # ... ë‚˜ë¨¸ì§€ í•¸ë“¤ëŸ¬
```

---

## 7. êµ¬í˜„ ìˆœì„œ ë° ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1: ì§„ë‹¨ ë„êµ¬ (ë¨¼ì €)
- [ ] `utils/profiler.py` ìƒì„±
- [ ] ê¸°ì¡´ ì½”ë“œì— í”„ë¡œíŒŒì¼ë§ ì ìš©
- [ ] ë¡œê·¸ í™•ì¸í•˜ì—¬ ì‹¤ì œ ë³‘ëª© íŒŒì•…

### Phase 2: ì•ˆì •ì„± ê°œì„ 
- [x] ~~`context_menu.py` ì ì‘í˜• ì¬ì‹œë„ ì ìš©~~ [íê¸°ë¨ - NVDA ë„¤ì´í‹°ë¸Œ ë™ì‘ì— ìœ„ì„]
- [ ] `keyboard_nav.py` ê°œë³„ unhook ì ìš©
- [ ] `utils/com_manager.py` ìƒì„± ë° ì ìš©

### Phase 3: ì„±ëŠ¥ ìµœì í™”
- [ ] `uia_utils.py` ìŠ¤ë§ˆíŠ¸ í•„í„°ë§ ì ìš©
- [ ] `main.py` í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„° ìµœì í™” ì ìš©
- [ ] í”„ë¡œíŒŒì¼ ë¦¬í¬íŠ¸ ê²€í†  ë° ì¶”ê°€ íŠœë‹

### Phase 4: ê²€ì¦
- [ ] í”„ë¡œíŒŒì¼ ë¡œê·¸ ë¶„ì„
- [ ] CPU ì‚¬ìš©ëŸ‰ ë¹„êµ (before/after)
- [ ] ë©”ë‰´ íƒìƒ‰ ì„±ê³µë¥  í™•ì¸
- [ ] NVDA í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸

---

## 8. í´ì½” ì§€ì‹œì‚¬í•­

```
ë‹¤ìŒ ìˆœì„œë¡œ ê°œì„  ì‘ì—…ì„ ì§„í–‰í•´ì¤˜:

1. utils/profiler.py ìƒì„± (ì´ ë¬¸ì„œì˜ ì½”ë“œ ì°¸ê³ )
2. utils/com_manager.py ìƒì„±
3. ~~context_menu.pyì— AdaptiveMenuFinder ì ìš©~~ [íê¸°ë¨]
4. uia_utils.pyì— SmartListFilter ì ìš©
5. keyboard_nav.py ê°œë³„ unhook ì ìš©
6. main.py í¬ì»¤ìŠ¤ ëª¨ë‹ˆí„° ìµœì í™” ì ìš©

ê° ë‹¨ê³„ë§ˆë‹¤:
- ê¸°ì¡´ ì½”ë“œ ë°±ì—…
- ìƒˆ ì½”ë“œ ì ìš©
- ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ (ì—ëŸ¬ ì—†ì´ ì‹¤í–‰ë˜ëŠ”ì§€)
- ì»¤ë°‹

Phase 1 (profiler) ì™„ë£Œ í›„ í•œë²ˆ ì‹¤í–‰í•´ì„œ ë¡œê·¸ í™•ì¸í•  ê±°ì•¼.
```
